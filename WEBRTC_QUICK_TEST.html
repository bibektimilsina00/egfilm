<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC STUN/TURN Test</title>
    <style>
        body {
            font-family: monospace;
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #0f0;
        }

        .test-section {
            background: #222;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 3px solid #0f0;
        }

        .success {
            color: #0f0;
        }

        .error {
            color: #f00;
        }

        .pending {
            color: #ff0;
        }

        button {
            background: #0f0;
            color: #000;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #0a0;
        }
    </style>
</head>

<body>
    <h1>üîç WebRTC STUN/TURN Test</h1>

    <div class="test-section">
        <h2>STUN Server Connectivity</h2>
        <button onclick="testSTUN()">Test STUN Servers</button>
        <div id="stun-results"></div>
    </div>

    <div class="test-section">
        <h2>P2P Connection Test</h2>
        <button onclick="testP2P()">Test P2P Connection</button>
        <div id="p2p-results"></div>
    </div>

    <div class="test-section">
        <h2>Network Diagnostics</h2>
        <button onclick="networkInfo()">Get Network Info</button>
        <div id="network-results"></div>
    </div>

    <script>
        async function testSTUN() {
            const results = document.getElementById('stun-results');
            results.innerHTML = '<p class="pending">Testing STUN servers...</p>';

            const servers = [
                'stun.l.google.com:19302',
                'stun1.l.google.com:19302',
                'stun2.l.google.com:19302',
                'stun3.l.google.com:19302',
                'stun4.l.google.com:19302'
            ];

            let html = '';
            for (const server of servers) {
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: `stun:${server}` }]
                });

                let found = false;
                const timeout = setTimeout(() => {
                    if (!found) {
                        html += `<p class="error">‚ùå ${server} - Timeout</p>`;
                    }
                }, 5000);

                pc.onicecandidate = (e) => {
                    if (e.candidate && !found) {
                        found = true;
                        clearTimeout(timeout);
                        html += `<p class="success">‚úÖ ${server} - Working</p>`;
                        results.innerHTML = html;
                    }
                };

                try {
                    await pc.createOffer();
                } catch (e) {
                    html += `<p class="error">‚ùå ${server} - Error: ${e.message}</p>`;
                    results.innerHTML = html;
                }
            }
        }

        async function testP2P() {
            const results = document.getElementById('p2p-results');
            results.innerHTML = '<p class="pending">Testing P2P connection...</p>';

            try {
                // Create two peer connections
                const pc1 = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                const pc2 = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                let html = '<p>PC1 and PC2 created</p>';

                // Exchange offers/answers
                pc1.onicecandidate = (e) => {
                    if (e.candidate) {
                        pc2.addIceCandidate(e.candidate);
                        html += `<p class="pending">PC1 ‚Üí PC2: ICE candidate</p>`;
                        results.innerHTML = html;
                    }
                };

                pc2.onicecandidate = (e) => {
                    if (e.candidate) {
                        pc1.addIceCandidate(e.candidate);
                        html += `<p class="pending">PC2 ‚Üí PC1: ICE candidate</p>`;
                        results.innerHTML = html;
                    }
                };

                pc1.onconnectionstatechange = () => {
                    html += `<p>PC1 connection state: ${pc1.connectionState}</p>`;
                    results.innerHTML = html;
                };

                pc2.onconnectionstatechange = () => {
                    html += `<p>PC2 connection state: ${pc2.connectionState}</p>`;
                    results.innerHTML = html;
                };

                const offer = await pc1.createOffer();
                await pc1.setLocalDescription(offer);
                await pc2.setRemoteDescription(offer);

                const answer = await pc2.createAnswer();
                await pc2.setLocalDescription(answer);
                await pc1.setRemoteDescription(answer);

                html += `<p class="pending">Exchange initiated. Waiting for connection...</p>`;
                results.innerHTML = html;

                setTimeout(() => {
                    html += `<p>PC1 ICE state: ${pc1.iceConnectionState}</p>`;
                    html += `<p>PC2 ICE state: ${pc2.iceConnectionState}</p>`;
                    if (pc1.iceConnectionState === 'connected' || pc1.iceConnectionState === 'completed') {
                        html += `<p class="success">‚úÖ P2P Connection Successful!</p>`;
                    } else {
                        html += `<p class="error">‚ùå P2P Connection Failed</p>`;
                    }
                    results.innerHTML = html;
                    pc1.close();
                    pc2.close();
                }, 10000);

            } catch (e) {
                results.innerHTML = `<p class="error">‚ùå Error: ${e.message}</p>`;
            }
        }

        function networkInfo() {
            const results = document.getElementById('network-results');
            const pc = new RTCPeerConnection();

            let html = '<p>Gathering network info...</p>';

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    const parts = e.candidate.candidate.split(' ');
                    html += `<p><strong>Candidate:</strong> ${parts[4]} (${parts[7]})</p>`;
                    results.innerHTML = html;
                }
            };

            pc.createDataChannel('test');
            pc.createOffer().then(offer => pc.setLocalDescription(offer));

            setTimeout(() => {
                html += `<p class="success">Done</p>`;
                results.innerHTML = html;
                pc.close();
            }, 5000);
        }
    </script>
</body>

</html>